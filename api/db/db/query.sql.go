// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCompetition = `-- name: CreateCompetition :exec
INSERT INTO competitions (
    id,
    name,
    created_at,
    updated_at,
    deleted_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type CreateCompetitionParams struct {
	ID        uuid.UUID
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

// Insert a new competition into the database
func (q *Queries) CreateCompetition(ctx context.Context, arg CreateCompetitionParams) error {
	_, err := q.db.ExecContext(ctx, createCompetition,
		arg.ID,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const createGame = `-- name: CreateGame :exec
INSERT INTO games (
    id,
    season_id,
    round,
    date,
    home_team_id,
    away_team_id,
    home_score,
    away_score,
    status,
    created_at,
    updated_at,
    deleted_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
`

type CreateGameParams struct {
	ID         uuid.UUID
	SeasonID   uuid.UUID
	Round      int32
	Date       time.Time
	HomeTeamID uuid.UUID
	AwayTeamID uuid.UUID
	HomeScore  sql.NullInt32
	AwayScore  sql.NullInt32
	Status     GameStatus
	CreatedAt  time.Time
	UpdatedAt  time.Time
	DeletedAt  sql.NullTime
}

// Insert a new game into the database
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) error {
	_, err := q.db.ExecContext(ctx, createGame,
		arg.ID,
		arg.SeasonID,
		arg.Round,
		arg.Date,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const createSeason = `-- name: CreateSeason :exec
INSERT INTO seasons (
	id,
	competition_id,
	start_date,
	end_date,
	rounds,
	created_at,
	updated_at,
	deleted_at
)
VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8
)
`

type CreateSeasonParams struct {
	ID            uuid.UUID
	CompetitionID uuid.UUID
	StartDate     time.Time
	EndDate       time.Time
	Rounds        int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	DeletedAt     sql.NullTime
}

// Insert a new season into the database
func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) error {
	_, err := q.db.ExecContext(ctx, createSeason,
		arg.ID,
		arg.CompetitionID,
		arg.StartDate,
		arg.EndDate,
		arg.Rounds,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const createSeasonTeams = `-- name: CreateSeasonTeams :exec
INSERT INTO season_teams (
  id,
  team_id,
  season_id,
  created_at,
  updated_at,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
`

type CreateSeasonTeamsParams struct {
	ID        uuid.UUID
	TeamID    uuid.UUID
	SeasonID  uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

// Insert a new season_teams relationship
func (q *Queries) CreateSeasonTeams(ctx context.Context, arg CreateSeasonTeamsParams) error {
	_, err := q.db.ExecContext(ctx, createSeasonTeams,
		arg.ID,
		arg.TeamID,
		arg.SeasonID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (
	id,
	name,
	abbreviation,
	location,
	created_at,
	updated_at,
	deleted_at
)
VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7
)
`

type CreateTeamParams struct {
	ID           uuid.UUID
	Name         string
	Abbreviation string
	Location     string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	DeletedAt    sql.NullTime
}

// Insert a new team into the database
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) error {
	_, err := q.db.ExecContext(ctx, createTeam,
		arg.ID,
		arg.Name,
		arg.Abbreviation,
		arg.Location,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const deleteCompetition = `-- name: DeleteCompetition :exec
UPDATE competitions
SET
	deleted_at = $1
WHERE
	id = $2
AND
	deleted_at IS NULL
`

type DeleteCompetitionParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

// Soft delete a competition
func (q *Queries) DeleteCompetition(ctx context.Context, arg DeleteCompetitionParams) error {
	_, err := q.db.ExecContext(ctx, deleteCompetition, arg.DeletedAt, arg.ID)
	return err
}

const deleteGame = `-- name: DeleteGame :exec
UPDATE games
SET
    deleted_at = $1
WHERE
    id = $2
AND
    deleted_at IS NULL
`

type DeleteGameParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

// Soft delete a game
func (q *Queries) DeleteGame(ctx context.Context, arg DeleteGameParams) error {
	_, err := q.db.ExecContext(ctx, deleteGame, arg.DeletedAt, arg.ID)
	return err
}

const deleteGamesByCompetitionID = `-- name: DeleteGamesByCompetitionID :exec
UPDATE games
SET
    deleted_at = $1
WHERE
    season_id IN (
        SELECT id
        FROM seasons
        WHERE competition_id = $2
          AND deleted_at IS NULL
    )
AND
    deleted_at IS NULL
`

type DeleteGamesByCompetitionIDParams struct {
	DeletedAt     sql.NullTime
	CompetitionID uuid.UUID
}

// Soft delete all games belonging to a competition via seasons
func (q *Queries) DeleteGamesByCompetitionID(ctx context.Context, arg DeleteGamesByCompetitionIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteGamesByCompetitionID, arg.DeletedAt, arg.CompetitionID)
	return err
}

const deleteGamesBySeasonID = `-- name: DeleteGamesBySeasonID :exec
UPDATE games
SET
  deleted_at = $1
WHERE
  season_id = $2
AND
  deleted_at IS NULL
`

type DeleteGamesBySeasonIDParams struct {
	DeletedAt sql.NullTime
	SeasonID  uuid.UUID
}

// Soft delete all games for a given season
func (q *Queries) DeleteGamesBySeasonID(ctx context.Context, arg DeleteGamesBySeasonIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteGamesBySeasonID, arg.DeletedAt, arg.SeasonID)
	return err
}

const deleteSeason = `-- name: DeleteSeason :exec
UPDATE seasons
SET
	deleted_at = $1
WHERE
	id = $2
AND
	deleted_at IS NULL
`

type DeleteSeasonParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

// Soft delete a season
func (q *Queries) DeleteSeason(ctx context.Context, arg DeleteSeasonParams) error {
	_, err := q.db.ExecContext(ctx, deleteSeason, arg.DeletedAt, arg.ID)
	return err
}

const deleteSeasonTeam = `-- name: DeleteSeasonTeam :exec
UPDATE season_teams
SET
  deleted_at = $1
WHERE
  id = $2
AND
  deleted_at IS NULL
`

type DeleteSeasonTeamParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

// Soft delete a team_season record
func (q *Queries) DeleteSeasonTeam(ctx context.Context, arg DeleteSeasonTeamParams) error {
	_, err := q.db.ExecContext(ctx, deleteSeasonTeam, arg.DeletedAt, arg.ID)
	return err
}

const deleteSeasonTeamsBySeasonID = `-- name: DeleteSeasonTeamsBySeasonID :exec
UPDATE season_teams
SET
  deleted_at = $1
WHERE
  season_id = $2
AND
  deleted_at IS NULL
`

type DeleteSeasonTeamsBySeasonIDParams struct {
	DeletedAt sql.NullTime
	SeasonID  uuid.UUID
}

// Soft delete all team_season records for a given season
func (q *Queries) DeleteSeasonTeamsBySeasonID(ctx context.Context, arg DeleteSeasonTeamsBySeasonIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteSeasonTeamsBySeasonID, arg.DeletedAt, arg.SeasonID)
	return err
}

const deleteSeasonsByCompetitionID = `-- name: DeleteSeasonsByCompetitionID :exec
UPDATE seasons
SET
    deleted_at = $1
WHERE
    competition_id = $2
AND
    deleted_at IS NULL
`

type DeleteSeasonsByCompetitionIDParams struct {
	DeletedAt     sql.NullTime
	CompetitionID uuid.UUID
}

// Soft delete all seasons for a competition
func (q *Queries) DeleteSeasonsByCompetitionID(ctx context.Context, arg DeleteSeasonsByCompetitionIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteSeasonsByCompetitionID, arg.DeletedAt, arg.CompetitionID)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
UPDATE teams
SET
	deleted_at = $1
WHERE
	id = $2
AND
	deleted_at IS NULL
`

type DeleteTeamParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

// Soft delete a team
func (q *Queries) DeleteTeam(ctx context.Context, arg DeleteTeamParams) error {
	_, err := q.db.ExecContext(ctx, deleteTeam, arg.DeletedAt, arg.ID)
	return err
}

const getCompetition = `-- name: GetCompetition :one
SELECT 
	id,
	name,
	created_at,
	updated_at,
	deleted_at 
FROM 
	competitions
WHERE 
	id = $1
AND
	deleted_at IS NULL
`

// Fetch a competition by id, excluding soft-deleted competitions
func (q *Queries) GetCompetition(ctx context.Context, id uuid.UUID) (Competition, error) {
	row := q.db.QueryRowContext(ctx, getCompetition, id)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCompetitions = `-- name: GetCompetitions :many
SELECT
	id,
	name,
	created_at,
	updated_at,
	deleted_at 
FROM
	competitions
WHERE
	deleted_at IS NULL
`

// Fetch all competitions, excluding soft-deleted competitions
func (q *Queries) GetCompetitions(ctx context.Context) ([]Competition, error) {
	rows, err := q.db.QueryContext(ctx, getCompetitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Competition
	for rows.Next() {
		var i Competition
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGame = `-- name: GetGame :one
SELECT
    id,
    season_id,
    round,
    date,
    home_team_id,
    away_team_id,
    home_score,
    away_score,
    status,
    created_at,
    updated_at,
    deleted_at
FROM
    games
WHERE
    id = $1
AND
    deleted_at IS NULL
`

// Fetch a game by id, excluding soft-deleted games
func (q *Queries) GetGame(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.Round,
		&i.Date,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGames = `-- name: GetGames :many
SELECT
    id,
    season_id,
    round,
    date,
    home_team_id,
    away_team_id,
    home_score,
    away_score,
    status,
    created_at,
    updated_at,
    deleted_at
FROM
    games
WHERE
    season_id = $1
AND
    deleted_at IS NULL
`

// Fetch all games for a season, excluding soft-deleted games
func (q *Queries) GetGames(ctx context.Context, seasonID uuid.UUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGames, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.Round,
			&i.Date,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT
	id,
	competition_id,
	start_date,
	end_date,
	rounds,
	created_at,
	updated_at,
	deleted_at
FROM
	seasons
WHERE
	id = $1
AND
	deleted_at IS NULL
`

// Fetch a season by id, excluding soft-deleted seasons
func (q *Queries) GetSeason(ctx context.Context, id uuid.UUID) (Season, error) {
	row := q.db.QueryRowContext(ctx, getSeason, id)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.StartDate,
		&i.EndDate,
		&i.Rounds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSeasonTeams = `-- name: GetSeasonTeams :many
SELECT
  id,
  team_id,
  season_id,
  created_at,
  updated_at,
  deleted_at
FROM
  season_teams
WHERE
  season_id = $1
AND
  deleted_at IS NULL
`

type GetSeasonTeamsRow struct {
	ID        uuid.UUID
	TeamID    uuid.UUID
	SeasonID  uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

// Fetch all season_teams
func (q *Queries) GetSeasonTeams(ctx context.Context, seasonID uuid.UUID) ([]GetSeasonTeamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSeasonTeams, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonTeamsRow
	for rows.Next() {
		var i GetSeasonTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.SeasonID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasons = `-- name: GetSeasons :many
SELECT
	id,
	competition_id,
	start_date,
	end_date,
	rounds,
	created_at,
	updated_at,
	deleted_at
FROM
	seasons
WHERE
	competition_id = $1
AND
	deleted_at IS NULL
`

// Fetch all seasons for a competition, excluding soft-deleted seasons
func (q *Queries) GetSeasons(ctx context.Context, competitionID uuid.UUID) ([]Season, error) {
	rows, err := q.db.QueryContext(ctx, getSeasons, competitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Season
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.StartDate,
			&i.EndDate,
			&i.Rounds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT
	id,
	name,
	abbreviation,
	location,
	created_at,
	updated_at,
	deleted_at
FROM
	teams
WHERE
	id = $1
AND
	deleted_at IS NULL
`

// Fetch a team by id, excluding soft-deleted teams
func (q *Queries) GetTeam(ctx context.Context, id uuid.UUID) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Abbreviation,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTeams = `-- name: GetTeams :many
SELECT
	id,
	name,
	abbreviation,
	location,
	created_at,
	updated_at,
	deleted_at
FROM
	teams
WHERE
	deleted_at IS NULL
`

// Fetch all teams for a competition, excluding soft-deleted teams
func (q *Queries) GetTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Abbreviation,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompetition = `-- name: UpdateCompetition :exec
UPDATE competitions
SET
	name = $1
WHERE
	id = $2
AND
	deleted_at IS NULL
`

type UpdateCompetitionParams struct {
	Name string
	ID   uuid.UUID
}

// Update an existing competition by id
func (q *Queries) UpdateCompetition(ctx context.Context, arg UpdateCompetitionParams) error {
	_, err := q.db.ExecContext(ctx, updateCompetition, arg.Name, arg.ID)
	return err
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games
SET
    round = $1,
    date = $2,
    home_team_id = $3,
    away_team_id = $4,
    home_score = $5,
    away_score = $6,
    status = $7,
    updated_at = $8
WHERE
    id = $9
AND
    deleted_at IS NULL
`

type UpdateGameParams struct {
	Round      int32
	Date       time.Time
	HomeTeamID uuid.UUID
	AwayTeamID uuid.UUID
	HomeScore  sql.NullInt32
	AwayScore  sql.NullInt32
	Status     GameStatus
	UpdatedAt  time.Time
	ID         uuid.UUID
}

// Update an existing game by id
func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.ExecContext(ctx, updateGame,
		arg.Round,
		arg.Date,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateSeason = `-- name: UpdateSeason :exec
UPDATE seasons
SET
	competition_id = $1,
	start_date = $2,
	end_date = $3,
	rounds = $4,
	updated_at = $5
WHERE
	id = $6
AND	
	deleted_at IS NULL
`

type UpdateSeasonParams struct {
	CompetitionID uuid.UUID
	StartDate     time.Time
	EndDate       time.Time
	Rounds        int32
	UpdatedAt     time.Time
	ID            uuid.UUID
}

// Update an existing season by id
func (q *Queries) UpdateSeason(ctx context.Context, arg UpdateSeasonParams) error {
	_, err := q.db.ExecContext(ctx, updateSeason,
		arg.CompetitionID,
		arg.StartDate,
		arg.EndDate,
		arg.Rounds,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET
	name = $1,
	abbreviation = $2,
	location = $3,
	updated_at = $4
WHERE
	id = $5
AND
	deleted_at IS NULL
`

type UpdateTeamParams struct {
	Name         string
	Abbreviation string
	Location     string
	UpdatedAt    time.Time
	ID           uuid.UUID
}

// Update an existing team by id
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.db.ExecContext(ctx, updateTeam,
		arg.Name,
		arg.Abbreviation,
		arg.Location,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
